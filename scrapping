from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options 
from webdriver_manager.chrome import ChromeDriverManager
import time
import csv

# --- CONFIGURATION DU DRIVER ---
options = webdriver.ChromeOptions()

# 1. Mode Headless (Le script tourne en fond sans fenêtre)
# On utilise "=new" car c'est la version moderne qui imite parfaitement un vrai navigateur
options.add_argument("--headless=new") 

# 2. Taille de fenêtre (OBLIGATOIRE en headless)
# Sans ça, Steam peut ne pas charger les éléments car il pense que la fenêtre est minuscule
options.add_argument("--window-size=1920,1080")

# 3. User-Agent (Pour ne pas se faire repérer)
user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
options.add_argument(f'user-agent={user_agent}')

# 4. Anti-détection bot
options.add_argument("--disable-blink-features=AutomationControlled")

# 5. On lance le driver avec toutes ces options
print("Lancement du scraper en arrière-plan (Headless)...")
driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

driver.get("https://store.steampowered.com")

accept_button = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.ID, "acceptAllButton"))
)
accept_button.click()

time.sleep(2)

bouton_parcourir = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Parcourir')]"))
    )
bouton_parcourir.click()

time.sleep(2)

bouton_promo = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.XPATH, "//a[contains(@href, 'specials')]"))
)
bouton_promo.click()

time.sleep(5)

# Fonction pour scroller la page
def scroll_page(driver, scrolls=5, pause_time=2):
    """Scroll la page pour charger plus de jeux"""
    for i in range(scrolls):
        # Scroll vers le bas
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        print(f"Scroll {i+1}/{scrolls}")
        time.sleep(pause_time)

# Scroller la page pour charger plus de jeux
print("Scrolling de la page...")
scroll_page(driver, scrolls=5, pause_time=2)

bouton_afficherplus = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "//button[contains(., 'Afficher plus')]")))
bouton_afficherplus.click()

scroll_page(driver, scrolls=5, pause_time=2)

# on veut le titre le prix original e prix réduit la réduction et l'évaluation.

# 1. On récupère TOUTES les boîtes de jeux (les parents)
# On utilise find_elements (avec un 's') pour avoir une liste
# On cible d'abord le conteneur PRINCIPAL (sale_item_browser)
# Puis on cherche les jeux (ImpressionTrackedElement) à l'intérieur
liste_jeux = driver.find_elements(By.XPATH, "//div[contains(@class, 'sale_item_browser')]//div[contains(@class, 'ImpressionTrackedElement')]")

print(f"Nombre de jeux trouvés (filtrés) : {len(liste_jeux)}")

with open('jeux_steam.csv', 'w', newline='', encoding='utf-8') as f:
    writer = csv.writer(f)

    writer.writerow(["Titre", "Infos Prix", "Avis", "Résumé"])   
    
    # 2. On boucle sur chaque "boîte" une par une
    for jeu in liste_jeux:
        print("------------------------------------------------")
        try:
         # --- TITRE ---
            # ⚠️ ATTENTION AU POINT "." AU DÉBUT DU XPATH !
         # Le "." signifie "Cherche à l'intérieur de 'jeu', pas dans toute la page"
            titre = jeu.find_element(By.XPATH, ".//img").get_attribute("alt")
        except:
            titre = "Titre inconnu"

        try:
            # --- PRIX ---
            # On cherche la div de prix À L'INTÉRIEUR de la variable 'jeu'
            infos_prix = jeu.find_element(By.XPATH, ".//div[contains(@class, 'StoreSalePriceWidgetContainer')]").get_attribute("aria-label")
        except:
            infos_prix = "Pas de prix / Gratuit"

        try:
            # --- ÉVALUATION ---
            # Idem, on cherche l'avis À L'INTÉRIEUR de 'jeu'
            infos_eval = jeu.find_element(By.XPATH, ".//a[contains(@class, 'ReviewScore')]//div[@aria-label]").get_attribute("aria-label")
        except:
            infos_eval = "Pas d'évaluation"

        try:
            # --- RÉSUMÉ ---
            # On cherche la div dont la classe contient 'StoreSaleWidgetShortDesc'
            resume = jeu.find_element(By.XPATH, ".//div[contains(@class, 'StoreSaleWidgetShortDesc')]").text
        except:
            resume = "Pas de résumé disponible"

        # Affichage des résultats liés
        print(f"Jeu : {titre}")
        print(f"Prix : {infos_prix}")
        print(f"Avis : {infos_eval}")
        print(f"Résumé : {resume}")
        writer.writerow([titre, infos_prix, infos_eval, resume])
        print(f"Sauvegardé : {titre}")

print("--- FIN DU SCRAPING ---")
